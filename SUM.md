## 1.要设计一个关系型数据库应该怎么做?

* 第一个是存储部分.类似一个文件存储系统.将数据持久化到设备当中.  
* 第二是程序实例模块.来对存储进行逻辑上的管理.程序实例模块包含  
>①数据的逻辑关系,转化成存储关系的存储管理模块  
>②优化执行效率的缓存模块  
>③将sql语句进行解析的sql解析模块  
>④记录操作的日志管理模块  
>⑤多用户管理的权限划分模块  
>⑥灾难恢复的容灾机制模块  
>⑦优化查询效率的索引模块  
>⑧支持并发操作的锁模块.

## 2. 为什么要使用一个索引?
回答: 索引能够让我们避免全表扫描去查找数据, 提升查找效率
* 数据量很小的情况, 直接加载到内存中, 进行全表扫描就可以. 用到索引的话反而效率会很低
* 数据量很大的情况, 就要避免全表扫描情况的发生.就需要用到索引, 灵感来自字典.

### 2.1 什么样的信息能成为索引?
回答: 主键、唯一键等等, 只要是能够让数据具备一定区分性的字段都能够成为索引.
* 主键是一个很好的切入点, 主键, 唯一键, 普通键都可以作为索引.

### 2.2 索引的数据结构?
回答: 主流是B+Tree, mysql不支持BitMap. 基于InnoDB和MYISAM的mysql, 不显式支持哈希.
* 生成索引, 建立二叉查找树进行二分查找.
* 生成索引, 建立B-Tree结构进行查找
 > 平衡多路查找树B-Tree:    
 > 定义:根节点至少包括两个孩子; 树中的每个节点最多含有m个孩子(m >= 2) m取决于节点的容量
 以及相关的配置;除根节点和叶节点外, 其他每个节点至少有ceil(m/2)个孩子.(ceil表示取上限);
 所有叶子节点都位于同一层.     
 > 目的是让每个索引块尽可能的存储很多的信息, 让树的高度尽可能减少io次数.
![Image text](https://github.com/Fanxx7201/summary/blob/master/img/B-Tree.png)
* 生成索引, 建立B+-Tree结构进行查找
* 生成索引, 建立Hash结构进行查找

### 2.3密集索引和稀疏索引的区别?
* 密集索引: 文件中每个搜索码值都对应一个索引值.
> 叶子节点保存的不仅仅只是键值, 还保存了位于同一行记录里边其他列的信息, 由于密集索引决定了表的物理排列顺序, 一个表只能有一个物理排列顺序,
所以一个表只能有一个密集索引.
* 稀疏索引: 只为索引码的某些值建立索引项
> 叶子节点只保存了一个键位信息, 以及该行数据键位地址. 有的稀疏索引, 只保存了键位信息及主键, 定位到叶子节点之后,  
仍然要通过地址或者是主键信息进一步定位到数据. 
* 具体分析mysql.
> MYISAM: 其索引均属于稀疏索引.  
> InnoDB: 数据和索引存储在idb文件中, 保存在一起.
有且仅有一个密集索引. 这个密集索引的定位规则: 
①若一个主键被定义, 该主键则作为密集索引.
②若没有主键被定义, 该表的第一个唯一非空索引则作为密集索引.
③若不满足以上条件, innodb内部会生成一个隐藏主键(作为密集索引)

### 如何定位并优化慢查询SQL
* 第一步: 根据慢日志定位慢查询sql
> 慢日志记录了执行比较慢的sql.
* 第二步: 根据explain等工具分析sql
> 重点是type和extra关键字
> type: mysql找到数据行的方式. all 和index是效率最差的, 走全表扫描. 
> extra: 辅助我们了解sql执行的凡是
* 第三步: 修改sql或者尽量让sql走索引


### 联合索引的最左匹配原则的成因
> 向左前缀匹配原则, 重要的原则是mysql会一直向右匹配直到遇到范围查询(> , < , between, like) 就停止了.
比如a = 3 and b = 4 and c > 5 and d = 6 如果建立(a, b, c, d)顺序的索引, d用不到索引.
如果建立(a, b, d, c) 的索引则可以都用到. a, b, d的顺序可以任意调整.  
> = 和 in可以乱序. 比如a = 1 and b = 2 and c = 3建立 (a, b, c)索引可以任意顺序, 
mysql的查询优化器会帮你优化成索引可以识别的形式.  


### 索引是建立的越多越好吗
> 首先: 数据量小的表不需要建立索引, 这样会增加额外的开销.  
> 第二: 数据变更需要去维护索引, 更多的索引, 意味着更多的维护成本.
> 第三: 更多的索引, 意味着需要更多的空间.一百页的书有50页的目录,很不现实.