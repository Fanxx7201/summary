## JVM

### 1.谈谈你读JAVA的理解?
* 平台无关性
* GC
* 语言特性
* 面向对象
* 类库
* 异常处理

### 2.CompileOnce, RunAnywhere如何实现?
回答: 源代码.java文件, 通过javac的编译, 生成字节码文件, 保存到.class文件中去. 字节码和.class文件是跨平台的基础.  
有了.class文件, JVM(虚拟机)才能加载对应的类, JAVA提供了各种不同平台的虚拟机, 可以实现到处执行.
 **** 图片

* class文件: javac命令对代码进行编译. .class文件保存的是java文件翻译成的二进制字节码.java类中的属性、方法、常量信息等等都会被保存在.class文件当中.
会添加一个公有 常量属性(.class), 这个属性记录了类的相关信息及类型信息, 是class的一个实例. 

* javap: java自带的反汇编器. 可以看到java的字节码. (命令: javap -help, 打开帮助文档. -c是对代码进行反汇编)
> 什么是反汇编? 
> 编译: java文件通过javac编译, 生成字节码文件, 保存到.class文件中去.   
> 反编译: 将.class文件反编译成为java文件   
> 命令: javap -c 类的全限定类名  
> 不指定构造函数时, 编译器会为我们默认生成一个不带参的构造函数.  

### 2.1 为什么JVM不直接将源码解析成机器码去执行?
* 直接执行的话, 每次执行都需要进行各种检查, 而且这些检查不能被保留, 这样做了很多重复的事情.
* 兼容性的需求: 可以将别的语言解析成字节码, 能增加平台的兼容、拓展能力.

### 3.JVM如何加载.class文件?


### 3.1 理解java虚拟机?
* 虚拟机是抽象化的计算机. JVM有处理器, 堆栈, 寄存器等等...虚拟机屏蔽了底层操作系统的不同, 减少基于原生语言开发的复杂性.

### 3.2JVM架构?
 **** 图片
* Class loader: 加载我们刚编译好的class文件到内存中
* Execution Engine: 解析class文件中的字节码, 提交到操作系统中执行
* Native Interface: 融合不同的开发语言的原生库为java所用.
> 源码中的private static native接口, 指的就是Native Interface
* Runtime Data Area: JVM内存空间结构模型

### 4.谈谈反射?
回答: java反射机制, 是在运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法; 对于任意一个对象, 都能够调用它的任意方法和属性.
这种动态获取信息以及动态调用对象方法的功能, 称为java的反射机制.

### 4.1写一个反射的例子?

