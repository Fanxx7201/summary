### 1.线程安全问题的诱因
* 存在共享数据(临界资源)
* 存在多条线程共同操作这些共享数据

### 2.解决问题的根本方法?
* 同一时刻, 有且只有一个线程操作共享数据, 其他线程必须等到该线程处理完毕数据之后, 
再对共享数据进行操作.

### 3.synchronized互斥锁的特性?
* 互斥性: 即在同一时间, 只允许一个线程持有某个对象锁, 通过这种特性来实现多线程的
协调机制, 这样在同一时间, 只有一个线程对需要同步的代码块(复合操作)进行访问.互斥性也
称为操作的原子性.

* 可见性: 必须确保在锁被释放之前, 对共享变量所做的修改, 对于随后获取该锁的另一个线程是可见的.
(即在获得锁时, 应获得最新共享变量的值), 否则另一个线程可能是在本地缓存的某个副本上继续操作,
从而引起不一致.

* 注意: synchronized锁的不是代码, 锁的都是对象

### 4. 根据获取的锁的分类: 获取对象锁和获取类锁
* 获取对象锁的两种用法:
> 同步代码块(synchronized(this), synchronized(类实例对象)), 锁是小括号()中的实例对象
> 同步非静态方法(synchronized method), 锁是当前对象的实例对象

* 获取类锁的两种用法:
> 同步代码块(synchronized(类.class)), 锁时小括号()中的类对象(Class对象)
> 同步静态方法(synchronized static method), 锁时当前对象的类对象(Class对象).

### 5.对象锁和类锁的总结
1. 有线程访问对象的同步代码块时, 另外的线程可以访问该对象的非同步代码块
2. 若锁住的是同一个对象, 一个线程在访问对象的同步代码块时, 另一个访问对象的同步代码块的线程会被阻塞.
3. 若锁住的是同一个对象, 一个线程在访问对象的同步方法时, 另一个访问对象同步方法的线程会被阻塞.
4. 若锁住的是同一个对象, 一个线程在访问对象的同步代码块时, 另一个访问对象同步方法的线程会被阻塞, 反之亦然.
5. 同一个类的不同对象的对象锁互不干扰.
6. 类锁由于也是一种特殊的对象锁, 因此表现和上述1, 2, 3, 4一致.而由于一个类只有一把对象锁.所以同一个类的不同对象使用类锁将是同步的.
7. 类锁和对象锁互不干扰.

### 6.synchronized底层实现原理?
* 实现synchronized的基础
> java对象头(对象在内存中的布局包括对象头, 实例数据, 对象填充)

![Image text](https://github.com/Fanxx7201/summary/blob/master/img/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E7%BB%93%E6%9E%84.png)
> monitor: 每个java对象天生自带了一个看不见的锁.叫做内部锁.

### 6.1 什么是重入?
从互斥锁的设计上来说, 当一个线程试图操作一个由其他线程持有的对象锁的临界资源时, 
将会处于阻塞状态.
但当一个线程, 再次请求自己持有对象锁的临界资源时, 这种情况属于重入, 
是可以成功的.(synchronized)属于可
重入锁.
synchronized(this){
    System.out.println("Hello");
    synchronized(this){
        System.out.println("World");
    }
}

### 6.2 自旋锁 与 自适应自旋锁
* 自旋锁: 
> 许多情况下, 共享数据的锁定状态持续时间比较短, 为了这段时间, 去挂起和阻塞线程, 浪费性能. 
切换线程不值得. 多处理器的情况下, 完全可以让另一个没有获取到锁的线程等待一会儿, 
进行忙循环等待锁的释放, 但不放弃CPU执行权,
这个过程就叫做自旋.

> 缺点: 若锁被其他线程长时间占用, 会带来许多性能上的开销.

* 自适应自旋锁:
> 自旋的次数不再固定  
> 由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定

### 6.3 锁消除(是虚拟机另外一种锁优化)
* 更彻底的优化
> JIT编译时, 对运行上下文进行扫描, 去除不可能存在竞争的锁.

public void add(String str1, String str2){
    //StringBuffer是线程安全的(被synchronized修饰), 由于sb只会在append方法中使用, 不可能被其他线程引用
    //这里sb并没有return出去. 因此, sb属于不可能共享的资源, JVM会自动消除内部的锁 --为了提高性能.

    StringBuffer sb = new StringBuffer();
    sb.append(str1).append(str2);
}

### 6.4 锁粗化
* 通过扩大加锁的范围, 避免反复加锁和解锁.
* 比如在一个循环中, 反复的调用append()方法,jvm会判断这种情况, 避免反复加锁, 只加一次.

### 6.5 synchronized的四种状态
* 无锁
* 偏向锁: 减少同一线程获取锁的代价
> 大多数情况下, 锁不存在多线程竞争, 总是由同一线程多次获得.
> 核心思想: 如果一个线程获得了锁, 那么锁就进入了偏向模式. 此时MARK WORD的结构也变成了
偏向锁结构, 当该线程再次请求锁时, 无需再做任何同步操作, 即获取锁的过程只需要检查MARK WORD的锁
标记位为偏向锁以及当前线程id等于MARK WORD的ThreadID即可. 这样就省去了大量有关锁申请的操作.
> 不适用于锁竞争比较激烈的多线程场合
* 轻量级锁
> 由偏向锁升级而来的, 偏向锁运行在一个线程进入同步块的情况下, 当第二个线程加入到锁争用的时候, 
偏向锁会升级为轻量级锁.
> 适用场景: 线程交替执行同步块
> 若存在同一时间访问同一锁的情况, 就会导致轻量级锁膨胀为重量级锁.
* 重量级锁


![Image text](https://github.com/Fanxx7201/summary/blob/master/img/%E5%81%8F%E5%90%91%E9%94%81%2C%20%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%2C%20%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94.png)

### 7.Synchronized和ReentrantLock的区别?
回答:
1. Synchronized是关键字, ReentrantLock是类
2. ReentrantLock可以对获取锁的等待时间进行设置, 避免死锁
3. ReentrantLock可以获取各种锁的信息
4. ReentrantLock可以灵活地实现多路通知
5. 机制: sync操作MarkWord, lock调用Unsafe类的park()方法

* ReentrantLock将锁对象化.
> 判断是否有线程, 或者是某个特定线程, 在排队等待获取锁.
> 带超时的获取锁的尝试.
> 感知有没有成功获取锁.
* ReentrantLock
> 位于java.util.concurrent.locks包
> 和CountDownLatch, FutureTask, Semaphore 一样, 基于AQS(AbstractQueuedSynchronizer)实现
(AQS: 队列同步器.java并发用于构建锁, 或者其他组件的框架.是JUC的核心, 主要使用方式是继承.)
> 能够实现比Synchronized更细粒度的控制, 比如控制fairness(公平性)
> 调用lock()之后, 必须调用unlock()释放锁.
> 性能未必比synchronized高, 并且也是可重入的.

* ReentrantLock 公平性的设置
> ReentrantLock failLock = new ReentrantLock(true);
> 参数为true, 倾向于将锁赋予等待时间最久的线程. 这也就是公平性的配置.
> 公平锁: 获取锁的顺序, 按照先后调用lock方法的顺序(慎用)
> 非公平锁: 抢占的顺序不一定, 看运气
> synchronized是非公平锁.(看需求是否一定有公平性的需求, 否则没必要注意公平性)









