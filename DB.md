## 1.要设计一个关系型数据库应该怎么做?

* 第一个是存储部分.类似一个文件存储系统.将数据持久化到设备当中.  
* 第二是程序实例模块.来对存储进行逻辑上的管理.程序实例模块包含  
>①数据的逻辑关系,转化成存储关系的存储管理模块  
>②优化执行效率的缓存模块  
>③将sql语句进行解析的sql解析模块  
>④记录操作的日志管理模块  
>⑤多用户管理的权限划分模块  
>⑥灾难恢复的容灾机制模块  
>⑦优化查询效率的索引模块  
>⑧支持并发操作的锁模块.

## 2. 为什么要使用一个索引?
回答: 索引能够让我们避免全表扫描去查找数据, 提升查找效率
* 数据量很小的情况, 直接加载到内存中, 进行全表扫描就可以. 用到索引的话反而效率会很低
* 数据量很大的情况, 就要避免全表扫描情况的发生.就需要用到索引, 灵感来自字典.

### 2.1 什么样的信息能成为索引?
回答: 主键、唯一键等等, 只要是能够让数据具备一定区分性的字段都能够成为索引.
* 主键是一个很好的切入点, 主键, 唯一键, 普通键都可以作为索引.

### 2.2 索引的数据结构?
回答: 主流是B+Tree, mysql不支持BitMap. 基于InnoDB和MYISAM的mysql, 不显式支持哈希.
* 生成索引, 建立二叉查找树进行二分查找.
* 生成索引, 建立B-Tree结构进行查找
 > 平衡多路查找树B-Tree:    
 > 定义:根节点至少包括两个孩子; 树中的每个节点最多含有m个孩子(m >= 2) m取决于节点的容量
 以及相关的配置;除根节点和叶节点外, 其他每个节点至少有ceil(m/2)个孩子.(ceil表示取上限);
 所有叶子节点都位于同一层.     
 > 目的是让每个索引块尽可能的存储很多的信息, 让树的高度尽可能减少io次数.
![Image text](https://github.com/Fanxx7201/summary/blob/master/img/B-Tree.png)
* 生成索引, 建立B+-Tree结构进行查找
* 生成索引, 建立Hash结构进行查找

### 2.3密集索引和稀疏索引的区别?
* 密集索引: 文件中每个搜索码值都对应一个索引值.
> 叶子节点保存的不仅仅只是键值, 还保存了位于同一行记录里边其他列的信息, 由于密集索引决定了表的物理排列顺序, 一个表只能有一个物理排列顺序,
所以一个表只能有一个密集索引.
* 稀疏索引: 只为索引码的某些值建立索引项
> 叶子节点只保存了一个键位信息, 以及该行数据键位地址. 有的稀疏索引, 只保存了键位信息及主键, 定位到叶子节点之后,  
仍然要通过地址或者是主键信息进一步定位到数据. 
* 具体分析mysql.
> MYISAM: 其索引均属于稀疏索引.  
> InnoDB: 数据和索引存储在idb文件中, 保存在一起.
有且仅有一个密集索引. 这个密集索引的定位规则: 
①若一个主键被定义, 该主键则作为密集索引.
②若没有主键被定义, 该表的第一个唯一非空索引则作为密集索引.
③若不满足以上条件, innodb内部会生成一个隐藏主键(作为密集索引)

### 如何定位并优化慢查询SQL
* 第一步: 根据慢日志定位慢查询sql
> 慢日志记录了执行比较慢的sql.
* 第二步: 根据explain等工具分析sql 
> 重点是type和extra关键字
> type: mysql找到数据行的方式. all 和index是效率最差的, 走全表扫描. 
> extra: 辅助我们了解sql执行的凡是
* 第三步: 修改sql或者尽量让sql走索引


### 联合索引的最左匹配原则的成因
> 向左前缀匹配原则, 重要的原则是mysql会一直向右匹配直到遇到范围查询(> , < , between, like) 就停止了.
比如a = 3 and b = 4 and c > 5 and d = 6 如果建立(a, b, c, d)顺序的索引, d用不到索引.
如果建立(a, b, d, c) 的索引则可以都用到. a, b, d的顺序可以任意调整.  
> = 和 in可以乱序. 比如a = 1 and b = 2 and c = 3建立 (a, b, c)索引可以任意顺序, 
mysql的查询优化器会帮你优化成索引可以识别的形式.  


### 索引是建立的越多越好吗
> 首先: 数据量小的表不需要建立索引, 这样会增加额外的开销.  
> 第二: 数据变更需要去维护索引, 更多的索引, 意味着更多的维护成本.
> 第三: 更多的索引, 意味着需要更多的空间.一百页的书有50页的目录,很不现实.


### 3.锁模块之MYISAM和INOODB关于锁方面的区别
* MYISAM 默认用的是表级锁, 不支持行级锁
> 表级锁的意思是, 表进行查询的时候, MYISAM给这个表上了一个锁. 其他的命令要等到
这个查询完成的时候, 再处理其他的命令.
> lock table ***(表名) read (给表增加一个读锁)
> unlock tables (释放锁)

* InnoDB 默认用的是行级锁, 也支持表级锁

### InnoDB和MYISAM的区别?
* MYISAM: 
> 有一个变量专门存储数据行数, 所以count操作比较多的情况适用
> 查询多修改少
> 没有事务
* InnoDB:
> 支持事务, 可靠性要求高
> 数据增删改查比较频繁

### 数据库锁的分类?
* 按使用方式划分: 乐观锁,悲观锁
  悲观锁:
  对外界的修改持保守态度,依靠数据库提供的锁机制,在数据处理全程中用排它锁锁定(悲观锁的一种实现方式),即先取锁再访问的保守策略,
  数据的安全有保障,但是会增加数据库的开销,增加产生死锁的几率.
  乐观锁:
  认为外界的修改不会造成冲突,在数据提交时才会对数据的冲突与否进行检测,若发现错误则返回错误的信息,让用户决定怎么做.乐观锁并不使用数据库提供的所机制,采用记录数据版本(1.用版本号记录version(int) 2.用时间戳记录)的方式来实现. 先读取数据,得到version的值为versionValue;
  每次更新数据的时候,为了防止冲突,先去检查version再做更新,更新成功的话version+1,冲突的话将失败信息返回给用户.
  认为数据之间冲突的可能性较小,在提交时才检查版本,而不是在提交之前就锁住数据.不会产生死锁.
* 按操作划分: DML锁(多数据操作),DDL锁(对表结构操作) .
* 按加锁方式划分:自动锁,显示锁
  自动锁: insert,update,detele以及MyISAM的表锁,这是Mysql自动为我们上的.
  显示锁: select for update , lock in share mode这些我们显示加的锁.
* 按锁级别划分:共享锁,排它锁
* 按锁的粒度划分:表级锁,行级锁,页级锁


### 3.1数据库事务的四大特性(ACID)
* A: 原子性:事务包含的所有操作, 要么全执行要么全失败回滚.  
* C: 一致性: 数据库事务, 应满足完整性约束. 比如用户a和用户b, 加起来钱是2000, 不管怎么如何转账, 最终钱总数还是2000  
* I: 隔离性: 多个事务并发执行时, 一个事务的执行, 不应该影响其他事务的执行  
* D: 持久性: 一个事务提交之后, 对于数据的修改应该永久的保存在数据库当中. 持久性意味着, 数据库发生故障时, 已提交
 的更新不能丢失, 及对已提交事务的更新能恢复. 一旦一个事务被提交, DBMS必须保证提供适当的冗余, 使其耐得住系统的故障. 持久性主要在于DBMS
 的恢复性能. 比如InnoDB, 会将所有对页面的修改操作, 写入一个专门的文件, 并在数据库启动时, 从此文件进行恢复操作. REDOLOGFILE 

> DBMS: 数据库管理系统
### 3.2 事务隔离级别以及各级别下的并发访问问题
* 事务并发访问引起的问题以及如何避免                         
> 更新丢失 - mysql所有事务隔离级别在数据库层面上均已经避免     
> 脏读 - 读到session未提交数据.READ-COMMITTED事务隔离级别以上可避免(READ-UNCOMMITTED: 读未提交, 可能导致脏读)   
> 不可重复读 - REPEATABLE-READ事务隔离级别以上可避免
> 幻读 - SERIALIZABLE事务隔离级别可避免
   
