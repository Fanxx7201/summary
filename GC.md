### 1.对象被判定为垃圾的标准?
* 没有被其他对象引用的情况

### 2.判定对象是否为垃圾的算法?
* 引用计数算法
* 可达性分析算法

### 2.1 引用计数算法?
* 判断对象的引用数量
>> 通过判断对象的引用数量来决定对象是否可以被回收  
>> 每个对象实例都有一个引用计数器, 被引用则+1, 完成引用则-1  
>> 任何引用计数为0的对象实例可以被当做垃圾收集  
* 优缺点?
>> 优点: 执行效率高, 程序执行受影响较小  
>> 缺点: 无法检测出循环引用的情况, 导致内存泄露(子对象引用父对象, 父对象反过来引用子对象)

### 2.2 可达性分析算法?
* 通过判断对象的引用链是否可达来决定对象是否可以被回收
>> 离散数学的图论引用的, 程序把所有的引用关系看成一张图, 通过一系列的名为GC LOSE的
对象作为起始点, 从这些节点的对象向下搜索, 搜索所走过的路线被称为引用链. 即reference chain
如果没有任何引用链相连, 就说明是不可达的. 这证实这个对象不可用, 被标记为垃圾.

### 3.垃圾回收之回收算法
* 标记-清楚算法(Mark and Sweep)
>> 标记: 从根集合进行扫描, 对存活的对象进行标记
>> 清除: 对堆内存从头到尾进行线性遍历, 回收不可达对象内存
* 复制算法(Copying)
>> 分为对象面和空闲面
>> 对象在对象面上创建
>> 存活的对象被从对象面复制到空闲面
>> 将对象面所有对象内存清除
* 标记-整理算法(Compacting)
>> 标记: 从根集合进行扫描, 对存活的对象进行标记
>> 清除: 移动所有存活对象, 且按照内存地址次序依次排列, 然后将末端内存地址以后的内存全部回收
* 分代收集算法(Generational Collector)
>> 垃圾回收算法的组合拳
>> 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
>> 目的: 提高JVM的回收效率