# 8: 进程与线程的区别？

回答: 进程是资源分配的最小单位, 线程是CPU调度的最小单位.
1. 线程并能看作是独立应用, 而进程可以看作是独立的应用
2. 进程有独立的地址空间, 相互不影响, 线程只是进程的不同执行路径
3. 线程没有独立的地址空间, 多进程的程序比多线程的程序健壮
4. 进程的切换比线程的切换开销大.

* 串行: 初期计算机串行执行任务, 需要长时间等待客户输入数据
* 批处理: 预先将用户指令集中成清单, 批量串行处理用户的指令, 依然无法并发执行
* 进程: 进程独占内存空间, 保存各自的运行状态, 互相不干扰可以互相切换, 为并发处理提供可能
* 线程: 共享进程的内存资源, 互相间切换更快速, 支持更细粒度的任务控制, 使进程内的子任务得以并发执行.

# 8.1 java进程和线程的关系？
* java对操作系统提供的功能进行封装，包括进程和线程。
* 运行一个程序会产生一个进程， 进程包括至少一个线程
* 每个进程对应一个JVM实例， 多个线程共享JVM里的堆
* JAVA采用单线程编程模型， 程序会自动创建主线程
* 主线程可以创建子线程，原则上要后于子线程完成执行（因为要进行一系列的关系操作安装）

### 8.2 线程的start和run方法 的区别？
* start() 是新创建一个新的子线程， 并启动（调用JVM的startThread方法）
* run()方法知识Thread的一个普通方法的调用.还是在主线程的层面.

### 8.3 Thread和Runnable是什么关系?
* Thread是一个类, Runnable是一个接口.
* Thread是实现了Runnable接口的类, 使得run支持多线程
* 因类的单一继承原则, 推荐多使用Runnable接口

### 9.如何实现处理线程的返回值
实现的方式3种
1. 主线程等待法
>> 优点: 代码简单
>> 缺点: 需要代码完成循环等待, 如果等待变量过多, 会导致代码异常臃肿. 循环多久也不确定.没办法更精准的控制

2. 使用Thread类的join()阻塞当前线程以等待子线程处理完毕.
>> 优点: 代码简单
>> 缺点: 粒度不够细

3.通过Callable接口实现: 通过FutureTask Or线程池获取.

>>线程池的优势: 提交多个实现callable的方法的类, 让线程池并发去处理结果.方便统一管理




### 9.1 如何给run()方法传参?
* 构造函数传参
* 成员变量传参
* 回调函数传参


### 10.线程的状态?
* 新建:创建后尚未启动
* 运行(Runnable): running和ready
* 无限期等待(Waiting): 不会被分配CPU执行时间, 需要显式被唤醒
>> 没有设置Timeout参数的Object.wait() 方法   
>> 没有设置Timeout参数的Thread.join()方法   
>> LockSupport.park()方法  
* 限期等待(TimeWaiting):一定时间后系统自动唤醒
>> Thread.sleep()方法
>> 设置了Timeout参数的Object.wait()方法
>> 设置了Timeout参数的Thread.join方法
>> LockSupport.parkNanos()方法
>> LockSupport.partUntil()方法
* 阻塞(Blocked): 等待获取排他锁
* 结束(Terminated): 已终止线程的状态, 线程已经结束执行.

### 11.sleep和wait的区别?
* 基本的差别
>> sleep是Thread类的方法, wait是Object类中定义的方法  
>> sleep可以在任何地方使用. wait只能在synchronized方法或者是synchronized块中使用  
* 最主要的本质区别
>> Thread.sleep只会让出CPU, 不会导致锁行为的改变
>> Object.wait不仅让出CPU, 还会释放已经占有的同步资源锁.


### 12.notify 和 notifyAll的区别?(可以用来唤醒无限期等待中的线程.wait())
* notifyAll 会让所有处于等待池中的线程全部进入到锁池去竞争获取锁的机会.
* notyfy 只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会.

### 13.yield
* 概念:当调用Thread.yield()函数时, 会给线程调度器一个当前线程愿意让出CPU使用的暗示,
但是, 线程调度器可能会忽略这个暗示.(决定权在线程调度器)
* yield对锁没有影响. 并不会让当前线程让出已经占用的锁.

### 14.如何中断线程?
* 已经被抛弃的方法: 
>> stop() :由一个线程去停止另外一个线程, 暴力, 不安全  
>> suspend() 和resume()方法  
* 目前使用的方法: 
>> 调用interrupt(), 通知线程应该中断了,类似yield, 也是一种暗示.
>> 1.如果线程处于被阻塞状态, 线程会立即退出被阻塞状态, 抛出InterruptedException异常
>> 2.如果线程出去正常活动状态, 那么会将该线程的中断标志设置为true.被设置中断的线程将继续正常运行,不受影响.


*** 图片: 线程状态的总结





